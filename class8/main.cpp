#include <iostream>

using namespace std;


/**

    内容：前缀树+贪心算法

    案例，一个字符串类型的数组arr1，另一个字符串类型的数组arr2。arr2中有那些字符是arr1中出现的？请打印

        例如说["abc","bck","abd","ace"]

    这里我们说一下，经典的前缀树，我们的节点本身没有意义，但是，边是有意义的，每一条边就对应一个字符。

    但是有些时候，面对特殊情况，可能会给点补充上一些信息。

        比如说，给一个节点补充上pass（这个节点通过了多少次）,end（这个节点是多少个字符串的终止节点）值

    前缀树的优势，我们可以很快的查到这个数组有没有指定的字符串。

    并且，可以很容易的查看字符串数组中有没有用特定字符串作为前缀的（走到那个节点的pass值）

    另外，说明一下，如果字符的种类过于多的话，可以申请使用哈希表的方式：map<char,Node>

    算法都是类似的，不同的结构只是对于一些小细节不同。

    删除的时候，如果使用C++的话，需要注意，不同语言关于空间申请和释放存在不同，如果遇到一个节点没意义了，需要遍历到底手动去析构掉。

    或者说，在执行函数的时候，不去删除，先用一个set把那些需要删除的都保存下来。然后把那个失效的节点删了，后续的遍历下来然后删除。



    贪心算法

    在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法

    也就是做出局部最优解，进而得到整体最优解。

    比如，传世经典，会议室问题

        一个会议室不能同时容纳两个项目的宣讲，给一组项目，有每一个项目的开始和结束，我们希望这个会议室办的项目最多。

        这个的策略就是按照结束时间排序，每一次都是找最早结束的合法的项目。

    贪心策略的证明，一般都很难，一般是可以使用对数器。

    我们可以写一些比较暴力但是一定对的，然后和我们的贪心策略结果做比较。

    一般来说，几千上万个都一样，那就确认正确了。


    贪心算法案例2：字符串数组拼接，希望最终拼出来的大字符串有最小的字典序。

        策略1：数组元素之间比较字典序，从小到大拼接。

        这个方案存在错误

        因为如果元素长度不同，b,ba做输入就是不对的。

        答案策略：数组元素之间，不是单纯的比较字典序，而是两个元素一前一后，比较拼接之后的字典序大小。

            哪一个在前面的字典序小，就让哪一个在前面

        OK，找到答案了，但是为什么呢？不知道，证明？ 很难

    贪心策略在实现的时候，使用的一些技巧：

        1.根据某一个标准建立一个比较器来排序

        2.根据某一个标准建立一个比较器来组成堆


    贪心算法案例3：

        切金条，每一次切金条的代价是金条的长度。

        我们现在有一个数组，表示每一个人需要的金条长度，我们希望满足他们要求需要的代价最小。

        经典霍夫曼编码问题。（小根堆）


    贪心算法案例4：

        已知初始资金和可以做的项目次数。

        我们现在知道可做的项目的成本和利润。

        项目不可以重复去做。

        希望次数做完之后，最多能够回笼多少资金。

        可以先试用小根堆，记录项目的花费。然后我们取出来我们能够执行的项目，然后按照利润，使用大根堆排列这些项目。

        需要注意，这两个堆中的项目没有交集，小根堆拿出来的放到大根堆里面。



    补充案例，堆的应用：

        一个数据流，随时可以取得中位数。

        也是大小根堆配合。第一个数字直接大根堆，之后的数据，如果小于等于大根堆的堆顶，就进入大根堆，反之进小根堆。

        但是需要记得保持平衡，如果两个堆size差值来到了2，那么大的那个的堆顶数据进另一个。

        两个堆顶可以确保中位数就在这里。


    最后补充一个N皇后问题：

        这个问题很经典，不用说明题目情况。

        一个经典的回溯问题。

        思路都懂，但是可以优化。主要优化是使用的位运算。

        这里需要注意的就是这里不能超过32皇后问题，因为会很麻烦。

        逻辑策略：

            1.N皇后问题，我们生成一个32位二进制数，前面都是0，后面N位是1.

            2.检查皇后合法的做法。

                定义三个变量。只使用位信息

                分别表示，列，左斜线，右斜线限制，1位置不能放皇后

                利用位信息的左移和右移，可以在下一行的时候，更新新的限制信息。

                一开始，三个限制都没有，开始递归。

                limit&(三个限制的或)这里的1，就意味着可以放皇后。



**/


int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
