#include <iostream>

using namespace std;


/**

    图，首先来说，算法比较简单，但是因为表达方式的多样，导致同一个思路的算法，有多种不同的表示方式

    图的表达方式：

        邻接表法，以点集作为单位，每一个点，记录和他相连的节点，需要边长也可以

        邻接矩阵法：一个n*n的矩阵，其中n表示的是点数，（i,j）表示的意思是第i个和第j个节点的距离，如果两者之间没有边，就是正无穷

    算法本身不难，但是因为数据表达方式的变化，我们需要用新的数据结构来实现我们的算法

    面对这个问题的解决方法：用你最最喜欢的图表达方式，实现所有的算法。

    然后，面对新的数据结构，我们写一个接口，转化成我们常使用的结构即可。

    但是这个结构需要一定的调研，因为并不是任何一个结构都支持所有的算法。

    左神使用的结构：

        一个点集，一个边集

        Grapg{
            //这里的int的意思就是编号。用于哈希表的check
            map<int,Node> nodes;
            set<Edge> edges;
        }

        Node{
            int value;
            //入度，也就是指向这个点的边的数量
            int in;
            //出度，也就是从这个点指出去的边的数量。
            int out;
            //由这个点连接的其他节点，如果是有向图，那么这里特指那些，从这个点指出去的、
            list<Node> nexts;
            //由这个点连接的边
            list<Edge> edges;
        }

        Edge{
            int weight;
            Node from;
            Node to;
        }



    ok，我们现在可以来看算法了

    1.图的DFS，BFS，原理我们都知道，众所周知，BFS通过队列实现，但是！图可能有环，所以，需要一个set防止死循环

        队列进队列的同时，也要记得进set。换种说法，set记录的是我们BFS遇到的所有节点。但是需要注意，撞到重复点不是错了，只是重复点不进队列，不进行对应操作。

        如果城市本身不多，其实数组是比哈希表快的。不过这个就是常数时间。

    2.DFS通过栈来实现，略微难过BFS。DFS通过栈来实现。头结点在循环外进栈。

        每一次栈中弹出一个之后，循环check这个弹出节点的邻居，如果我们遇到了新的节点，我们把之前弹出的节点压回去，再压进去这个新的节点，然后set记录。然后处理这个新节点，然后break，不再看其他邻居节点。重复这个操作。

        这样做的目的，是通过我们的栈，永远保留着最大深度的路径。

    3.拓扑排序。

        经典作用场合就是前置课程情景。本质上是有向图的一种应用。

        这个算法很简单，就先看入度为0的点，这个点就在最前面，然后，抹除掉这个点，和这个点相关的边，然后会有一个新的点入度为0，重复这个操作。

        用一个队列来记录那些入度为零的点，摸出影响是一个循环，再循环这里就可以做判断，顺便将减到0的进队列

    4.生成最小生成树

        保证连通性的前提下，权值累加和最小就行

        这里需要留一个并查集的概念。

        方法1，克鲁斯卡尔算法，逻辑，每一次都找最小的边，没有形成环就放进去，

        逻辑其实很简单，但是唯一一个难点就是，你凭什么判断成环，这就是用并查集的地方。

            假设，一开始每一个点，都是一个单独的集合。每一次取一条边，我们就把点的集合放到一起。

            如果取的边两个点在两个集合里面，就不会成环，反之会成环，就需要放弃。

        好了，请问这个每一个点集，要怎么做到呢？说明一下，并查集操作是常数级别的。

        另外，边从小到大这里可以使用优先队列（其实就是堆）实现，更优雅一些

        方法2，prim算法，从点的角度来实现这个功能。

        每一次取一个点进入点集，然后把这个点集所有关联的边取最短的，然后把这个边的另一个点补充进来点集

        如果，我们这时候选择出来的边，两个点都在点集里面，那就意味着成环，是不可以的。

        这个的优势就是每一次只是一个点集+一个新的点，这样省下了并查集的麻烦。

        在过程中需要注意，在执行过程中，是有可能把一条边多次处理，但是当然，不会影响结构和复杂度

    5.迪杰斯特拉算法

        计算单元最短路径

        适用于没有权值为负数的边，这个很重要，如果有一个累加和为负数的环，那就很离谱那里，路径会无穷小。





**/



int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
